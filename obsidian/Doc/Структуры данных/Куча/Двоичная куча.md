__Куча__ - это структура данных, которая позволяет получить наибольший или наименьший элемент за O(1)

Куча поддерживает следующие операции:

- Нахождение минимума(максимума) - O(1)
- Удаление минимума(максимума) - O(log N)
- Добавление нового элемента в кучу O(log N)

# Устройство кучи
 
_Двоичная куча_ — реализация очереди с приоритетами, использующая дерево, для которого выполнены три условия:

1. Значение в любой вершине не больше(или меньше), чем значения её потомков.
2. У любой вершины не более двух сыновей.
3. Слои заполняются последовательно сверху вниз и слева направо, без «дырок».
4. Так как куча является полным двоичным деревом, то его можно хранить в виде массива!!!

![[MaxHeap.png]]

# Реализация куча

Для работы с кучей введем две операции _SiftDown_ и _SiftUp_, которые будут восстанавливать свойство кучи. 

Эти операции были реализованы для _минимальной кучи_.

## SiftUp

```go
func (heap *MinHeap[T]) siftUp(currentIndex int) {
	parentIndex := (currentIndex - 1) / 2
	for parentIndex >= 0 {
		if heap.items[parentIndex] > heap.items[currentIndex] {
			heap.Swap(currentIndex, parentIndex)
		} else {
			break
		}
		currentIndex = parentIndex
		parentIndex = (currentIndex - 1) / 2
	}
}
```

Идея метода: Проверить, существует ли родитель текущего узла, если он существует, то нужно сравнить значение родителя со значением текущего узла, если значение родителя больше, то мы меняем местами узлы и переходим на родительский узел, иначе выходим из цикла.

## SiftDown

```go
func (heap *MinHeap[T]) siftDown(currentIndex int) {
	leftIndex := 2*currentIndex + 1
	rightIndex := 2*currentIndex + 2
	for leftIndex <= heap.Length() {
		swapIndex := leftIndex
		if rightIndex <= heap.Length() && heap.items[rightIndex] < heap.items[leftIndex] {
			swapIndex = rightIndex
		}
		if heap.items[currentIndex] > heap.items[swapIndex] {
			heap.Swap(currentIndex, swapIndex)
			currentIndex = swapIndex
		} else {
			break
		}
	}
}
```

Идея метода: Мы должны найти ребенка с меньшим значением, если находим, то сравниваем его с родителем, если значение родителя будет строго больше значения ребенка, то мы их меняем местами и идем дальше вниз, иначе выходим их цикла.

Давайте введем _лемму_ о свойстве кучи:

> Если значение элемента уменьшилось, то мы проводим операцию _SiftUp_
> Если значение элемента увеличилось, то мы проводим операцию _SiftDown_

## Операции с кучей

### Добавлие элемента в кучу

```go
func (heap *MinHeap[T]) Add(value T) {
	heap.items = append(heap.items, value)
	heap.siftUp(heap.Length() - 1)
}
```

Идея метода: Добавляем элемент в конец массива и проводим операцию _SiftUp_ 

### Получить минимальный элемент

```go
func (heap *MinHeap[T]) getRoot() T {
	return heap.items[0]
}
```

Идея метода: Возвращаем элемент из корня кучи

### Удалить минимальный элемент

```go
func (heap *MinHeap[T]) DeleteRoot() error {
	if heap.Length() == 0 {
		return fmt.Errorf("The heap is empty")
	}
	
	lastIndex := heap.Length() - 1
	heap.items[0] = heap.items[lastIndex]
	heap.items = heap.items[:lastIndex]
	heap.siftDown(0)
	return nil
}
```

Идея метода: Меняем местами первый элемент с полсденим, послу удалаем последний элемент и проводим операцию _SiftDown_ с нулевого индекса то есть с корня.