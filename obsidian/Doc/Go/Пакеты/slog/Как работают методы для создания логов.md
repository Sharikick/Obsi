Логи создаются с помощью методов `Info`, `Warn`, `Error` и `Debug`

Эти методы предоставляет структура [[Logger]]

Но эти методы делегируют свою работу приватному методу `log`

```go
func (l *Logger) log(ctx context.Context, level Level, msg string, args ...any) {
	if !l.Enabled(ctx, level) {
		return
	}
	var pc uintptr
	if !internal.IgnorePC {
		var pcs [1]uintptr
		runtime.Callers(3, pcs[:])
		pc = pcs[0]
	}
	r := NewRecord(time.Now(), level, msg, pc)
	r.Add(args...)
	if ctx == nil {
		ctx = context.Background()
	}
	_ = l.Handler().Handle(ctx, r)
}
```

Метод `log` принимает:
- `ctx context.Context` - Контекст, который может передавать информацию
- `level Level` - Уровень записи(Warn, Error, Debug, Info)
- `msg string` - Сообщение лога
- `args ...any` - Дополнительные атрибуты

Как этот метод работает

1. Проверка уровня

```go
if !l.Enabled(ctx, level) {
  return
}
```

Метод `Enabled` возвращает `true`, если текущий уровень логгера позволяет записать сообщение уровня `level`

2. Получение контекста вызова:

```go
var pc uintptr
if !internal.IgnorePC {
  var pcs [1]uintptr
  runtime.Callers(3, pcs[:])
  pc = pcs[0]
}
```

Эта часть кода пытается получить адрес вызова функции (stack trace) для определения места в коде, где был вызван log. Эта информация может быть полезна для отладки. runtime.Callers() - это функция из стандартной библиотеки Golang, которая позволяет получить адрес стека вызывающих функций.

3. Создание записи и добавление атрибутов:

```go
r := NewRecord(time.Now(), level, msg, pc)
r.Add(args...)
```

В этой строке мы создаем объект `Record`, который представляет информацию о записи лога. После передаем все дополнительные атрибуты.

4. Обработка записи:

```go
if ctx == nil {
	ctx = context.Background()
}
_ = l.Handler().Handle(ctx, r)
```

Проверка на контекст, если он не был передан, то создается `context.Background()`. После получаем `Handler` логгера и у него вызываем метод `Handle`, который определяет куда и как записывать лог.

Есть альтернативный метод, который строго обрабатывает атрибуты.

```go
func (l *Logger) logAttrs(ctx context.Context, level Level, msg string, attrs ...Attr) {
	if !l.Enabled(ctx, level) {
		return
	}
	var pc uintptr
	if !internal.IgnorePC {
		var pcs [1]uintptr
		runtime.Callers(3, pcs[:])
		pc = pcs[0]
	}
	r := NewRecord(time.Now(), level, msg, pc)
	r.AddAttrs(attrs...)
	if ctx == nil {
		ctx = context.Background()
	}
	_ = l.Handler().Handle(ctx, r)
}
```

Отличается он от метода `log` тем, что принимает атрибуты строго типа [[Attr]]

